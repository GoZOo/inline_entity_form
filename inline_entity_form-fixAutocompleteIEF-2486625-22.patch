diff --git a/inline_entity_form.module b/inline_entity_form.module
index 6aaa091..39c294d 100644
--- a/inline_entity_form.module
+++ b/inline_entity_form.module
@@ -249,7 +249,7 @@ function inline_entity_form_reference_form($controller, $reference_form, &$form_
     '#type' => 'textfield',
     '#title' => t('@label', array('@label' => ucwords($labels['singular']))),
     '#autocomplete_route_name' => 'inline_entity_form.autocomplete',
-    '#autocomplete_route_parameters' => ['entity_type_id' => $instance->entity_type, 'field_name' => $instance->field_name, 'bundle' => $instance->bundle],
+    '#autocomplete_route_parameters' => ['entity_type_id' => $instance->getTargetEntityTypeId(), 'field_name' => $instance->field_name, 'bundle' => $instance->getTargetBundle()],
     '#element_validate' => array('_inline_entity_form_autocomplete_validate'),
     '#required' => TRUE,
     '#maxlength' => 255,
diff --git a/inline_entity_form.routing.yml b/inline_entity_form.routing.yml
index abc215f..eaad9c5 100644
--- a/inline_entity_form.routing.yml
+++ b/inline_entity_form.routing.yml
@@ -1,7 +1,7 @@
 inline_entity_form.autocomplete:
   path: inline_entity_form/autocomplete/{entity_type_id}/{field_name}/{bundle}
   defaults:
-    _controller: 'Drupal\inline_entity_form\AutocompleteController::autocomplete'
+    _controller: 'Drupal\inline_entity_form\Controller\AutocompleteController::autocomplete'
     _title: 'Inline Entity Form Autocomplete'
   requirements:
     _access: 'TRUE'
diff --git a/src/AutocompleteController.php b/src/AutocompleteController.php
deleted file mode 100644
index 4508fa3..0000000
--- a/src/AutocompleteController.php
+++ /dev/null
@@ -1,104 +0,0 @@
-<?php
-
-/**
- * @file
- * Contains \Drupal\inline_entity_form\AutocompleteController.
- */
-
-namespace Drupal\inline_entity_form;
-use Drupal\Component\Utility\String;
-use Drupal\Core\DependencyInjection\ContainerInjectionInterface;
-use Drupal\Core\Entity\EntityManagerInterface;
-use Symfony\Component\DependencyInjection\ContainerInterface;
-use Symfony\Component\HttpFoundation\JsonResponse;
-use Symfony\Component\HttpFoundation\Request;
-use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
-
-/**
- * Defines the autocompletion controller method.
- */
-class AutocompleteController implements ContainerInjectionInterface {
-
-  /** @var \Drupal\Core\Entity\EntityManagerInterface  */
-  protected $entityManager;
-
-  /**
-   * Constructsa a new AutocompleteController object.
-   *
-   * @param \Drupal\Core\Entity\EntityManagerInterface $entity_manager
-   */
-  public function __construct(EntityManagerInterface $entity_manager) {
-    $this->entityManager = $entity_manager;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public static function create(ContainerInterface $container) {
-    return new static(
-      $container->get('entity.manager')
-    );
-  }
-
-  /**
-   * Handles the response for inline entity form autocompletion.
-   *
-   * @return \Symfony\Component\HttpFoundation\JsonResponse
-   */
-  public function autocomplete($entity_type_id, $field_name, $bundle, Request $request) {
-    $string = $request->query->get('q');
-
-    $fields = $this->entityManager->getFieldDefinitions($entity_type_id, $bundle);
-
-    $field = $fields[$field_name];
-    $storage = $field->getFieldStorageDefinition();
-    $settings = $storage->getSettings();
-    $controller = inline_entity_form_get_controller($field);
-    $widget = \Drupal::entityManager()
-      ->getStorage('entity_form_display')
-      ->load($entity_type_id . '.' . $bundle . '.default')
-      ->getComponent($field_name);
-
-    // The current entity type is not supported, or the string is empty.
-    // strlen() is used instead of empty() since '0' is a valid value.
-    if (!$field || !$storage || !$controller || !strlen($string)) {
-      throw new AccessDeniedHttpException();
-    }
-
-    $results = array();
-    if ($field->getType() == 'commerce_product_reference') {
-      $match_operator = strtolower($widget['settings']['match_operator']);
-      $products = commerce_product_match_products($field, $storage, $string, $match_operator, array(), 10, TRUE);
-
-      // Loop through the products and convert them into autocomplete output.
-      foreach ($products as $product_id => $data) {
-        $results[] = t('@label (!entity_id)', array('@label' => $data['title'], '!entity_id' => $product_id));
-      }
-    }
-    elseif ($field->getType() == 'entity_reference') {
-      /** @var \Drupal\entity_reference\Plugin\Type\SelectionPluginManager $selection_manager */
-      $selection_manager = \Drupal::service('plugin.manager.entity_reference.selection');
-      /** @var \Drupal\entity_reference\Plugin\Type\Selection\SelectionInterface $handler */
-      $handler = $selection_manager->getSelectionHandler($field);
-      $entity_labels = $handler->getReferenceableEntities($string, $widget['settings']['match_operator'], 10);
-
-      foreach ($entity_labels as $bundle => $labels) {
-        // Loop through each entity type, and autocomplete with its titles.
-        foreach ($labels as $entity_id => $label) {
-          // entityreference has already check_plain-ed the title.
-          $results[] = t('!label (!entity_id)', array('!label' => $label, '!entity_id' => $entity_id));
-        }
-      }
-    }
-
-    $matches = array();
-    foreach ($results as $result) {
-      // Strip things like starting/trailing white spaces, line breaks and tags.
-      $key = preg_replace('/\s\s+/', ' ', str_replace("\n", '', trim(String::decodeEntities(strip_tags($result)))));
-      $matches[] = ['value' => $key, 'label' => '<div class="reference-autocomplete">' . $result . '</div>'];
-    }
-
-    return new JsonResponse($matches);
-  }
-
-}
diff --git a/src/Controller/AutocompleteController.php b/src/Controller/AutocompleteController.php
new file mode 100644
index 0000000..291b428
--- /dev/null
+++ b/src/Controller/AutocompleteController.php
@@ -0,0 +1,107 @@
+<?php
+
+/**
+ * @file
+ * Contains \Drupal\inline_entity_form\Controller\AutocompleteController.
+ */
+
+namespace Drupal\inline_entity_form\Controller;
+
+use Drupal\Component\Utility\Html;
+use Drupal\Core\DependencyInjection\ContainerInjectionInterface;
+use Drupal\Core\Entity\EntityManagerInterface;
+use Drupal\Core\Entity\EntityReferenceSelection\SelectionPluginManagerInterface;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+use Symfony\Component\HttpFoundation\JsonResponse;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
+
+/**
+ * Defines the autocompletion controller method.
+ */
+class AutocompleteController implements ContainerInjectionInterface {
+
+  /**
+   * Entity manager service.
+   *
+   * @var \Drupal\Core\Entity\EntityManagerInterface
+   */
+  protected $entityManager;
+
+  /**
+   * Selection manager service.
+   *
+   * @var \Drupal\Core\Entity\EntityReferenceSelection\SelectionPluginManagerInterface
+   */
+  protected $selectionManager;
+
+  /**
+   * Constructs a new AutocompleteController object.
+   *
+   * @param \Drupal\Core\Entity\EntityManagerInterface $entity_manager
+   */
+  public function __construct(EntityManagerInterface $entity_manager, SelectionPluginManagerInterface $selection_manager) {
+    $this->entityManager = $entity_manager;
+    $this->selectionManager = $selection_manager;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container) {
+    return new static(
+      $container->get('entity.manager'),
+      $container->get('plugin.manager.entity_reference_selection')
+    );
+  }
+
+  /**
+   * Handles the response for inline entity form autocompletion.
+   *
+   * @return \Symfony\Component\HttpFoundation\JsonResponse
+   */
+  public function autocomplete($entity_type_id, $field_name, $bundle, Request $request) {
+    $string = $request->query->get('q');
+
+    $fields = $this->entityManager->getFieldDefinitions($entity_type_id, $bundle);
+
+    $field = $fields[$field_name];
+    $storage = $field->getFieldStorageDefinition();
+    $controller = inline_entity_form_get_controller($field);
+    $widget = $this->entityManager
+      ->getStorage('entity_form_display')
+      ->load($entity_type_id . '.' . $bundle . '.default')
+      ->getComponent($field_name);
+
+    // The current entity type is not supported, or the string is empty.
+    // strlen() is used instead of empty() since '0' is a valid value.
+    if (!$field || !$storage || !$controller || !strlen($string)) {
+      throw new AccessDeniedHttpException();
+    }
+
+    $results = array();
+    if ($field->getType() == 'entity_reference') {
+      /** @var \Drupal\Core\Entity\EntityReferenceSelection\SelectionInterface $handler */
+      $handler = $this->selectionManager->getSelectionHandler($field);
+      $entity_labels = $handler->getReferenceableEntities($string, $widget['settings']['match_operator'], 10);
+
+      foreach ($entity_labels as $bundle => $labels) {
+        // Loop through each entity type, and autocomplete with its titles.
+        foreach ($labels as $entity_id => $label) {
+          // entityreference has already check_plain-ed the title.
+          $results[] = t('!label (!entity_id)', array('!label' => $label, '!entity_id' => $entity_id));
+        }
+      }
+    }
+
+    $matches = array();
+    foreach ($results as $result) {
+      // Strip things like starting/trailing white spaces, line breaks and tags.
+      $key = preg_replace('/\s\s+/', ' ', str_replace("\n", '', trim(Html::decodeEntities(strip_tags($result)))));
+      $matches[] = ['value' => $key, 'label' => '<div class="reference-autocomplete">' . $result . '</div>'];
+    }
+
+    return new JsonResponse($matches);
+  }
+
+}
diff --git a/src/Plugin/Field/FieldWidget/InlineEntityFormMultiple.php b/src/Plugin/Field/FieldWidget/InlineEntityFormMultiple.php
index 0285372..5bde64b 100644
--- a/src/Plugin/Field/FieldWidget/InlineEntityFormMultiple.php
+++ b/src/Plugin/Field/FieldWidget/InlineEntityFormMultiple.php
@@ -590,7 +590,6 @@ class InlineEntityFormMultiple extends WidgetBase implements ContainerFactoryPlu
         }
       }
       elseif ($form_state->get(['inline_entity_form', $this->getIefId(), 'form']) == 'ief_add_existing') {
-        // TODO - autocomplete seems to be broken and needs to be fixed.
         $element['form'] = array(
           '#type' => 'fieldset',
           '#attributes' => array('class' => array('ief-form', 'ief-form-bottom')),
